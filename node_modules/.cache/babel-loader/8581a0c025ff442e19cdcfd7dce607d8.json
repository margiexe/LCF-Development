{"ast":null,"code":"import _slicedToArray from \"C:/Users/Asus/Desktop/LCF-Deployment/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { ActionTypes } from './useListbox.types';\nimport areArraysEqual from '../utils/areArraysEqual';\n/**\r\n * Gets the current state. If the selectedValue is controlled,\r\n * the `value` prop is the source of truth instead of the internal state.\r\n */\n\nfunction getControlledState(internalState, props) {\n  if (props.value !== undefined) {\n    return _extends({}, internalState, {\n      selectedValue: props.value\n    });\n  }\n\n  return internalState;\n}\n\nfunction areOptionsEqual(option1, option2, optionComparer) {\n  if (option1 === option2) {\n    return true;\n  }\n\n  if (option1 === null || option2 === null) {\n    return false;\n  }\n\n  return optionComparer(option1, option2);\n}\n/**\r\n * Triggers change event handlers (onChange and onHighlightChange) when reducer returns changed state.\r\n *\r\n * @param nextState The next state returned by the reducer.\r\n * @param internalPreviousState The previous state. If the component is controlled, this is merged with the props to determine the final state.\r\n * @param propsRef The props with defaults applied.\r\n * @param lastActionRef The last action that was dispatched.\r\n */\n\n\nfunction useStateChangeDetection(nextState, internalPreviousState, propsRef, lastActionRef) {\n  React.useEffect(function () {\n    var _previousState$select;\n\n    if (!propsRef.current || lastActionRef.current === null) {\n      // Detect changes only if an action has been dispatched.\n      return;\n    }\n\n    if (lastActionRef.current.type === ActionTypes.setValue || lastActionRef.current.type === ActionTypes.setHighlight) {\n      // Don't fire change events when the value has been changed externally (e.g. by changing the controlled prop).\n      return;\n    }\n\n    var previousState = getControlledState(internalPreviousState, propsRef.current);\n    var _propsRef$current2 = propsRef.current,\n        optionComparer = _propsRef$current2.optionComparer,\n        onChange = _propsRef$current2.onChange;\n    var previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValues) != null ? _previousState$select : [];\n    var nextSelectedValues = nextState.selectedValues;\n\n    if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {\n      onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValues);\n    } // Fires the highlightChange event when reducer returns changed `highlightedValue`.\n\n\n    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {\n      var _propsRef$current, _propsRef$current$onH;\n\n      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, lastActionRef.current.event, nextState.highlightedValue);\n    }\n\n    lastActionRef.current = null;\n  }, [nextState.selectedValues, nextState.highlightedValue, internalPreviousState, propsRef, lastActionRef]);\n}\n/**\r\n * @ignore - do not document.\r\n */\n\n\nexport default function useControllableReducer(internalReducer, externalReducer, props) {\n  var _ref;\n\n  var _props$current = props.current,\n      value = _props$current.value,\n      defaultValue = _props$current.defaultValue;\n  var actionRef = React.useRef(null);\n  var initialSelectedValues = (_ref = value === undefined ? defaultValue : value) != null ? _ref : [];\n  var initialState = {\n    highlightedValue: null,\n    selectedValues: initialSelectedValues\n  };\n  var combinedReducer = React.useCallback(function (state, action) {\n    actionRef.current = action;\n\n    if (externalReducer) {\n      return externalReducer(getControlledState(state, action.props), action);\n    }\n\n    return internalReducer(getControlledState(state, action.props), action);\n  }, [externalReducer, internalReducer]);\n\n  var _React$useReducer = React.useReducer(combinedReducer, initialState),\n      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n      nextState = _React$useReducer2[0],\n      dispatch = _React$useReducer2[1];\n\n  var dispatchWithProps = React.useCallback(function (action) {\n    dispatch(_extends({\n      props: props.current\n    }, action));\n  }, [dispatch, props]);\n  var previousState = React.useRef(initialState);\n  React.useEffect(function () {\n    previousState.current = nextState;\n  }, [previousState, nextState]);\n  useStateChangeDetection(nextState, previousState.current, props, actionRef);\n  return [getControlledState(nextState, props.current), dispatchWithProps];\n}","map":{"version":3,"names":["_extends","React","ActionTypes","areArraysEqual","getControlledState","internalState","props","value","undefined","selectedValue","areOptionsEqual","option1","option2","optionComparer","useStateChangeDetection","nextState","internalPreviousState","propsRef","lastActionRef","useEffect","_previousState$select","current","type","setValue","setHighlight","previousState","onChange","previousSelectedValues","selectedValues","nextSelectedValues","event","highlightedValue","_propsRef$current","_propsRef$current$onH","onHighlightChange","call","useControllableReducer","internalReducer","externalReducer","_ref","defaultValue","actionRef","useRef","initialSelectedValues","initialState","combinedReducer","useCallback","state","action","useReducer","dispatch","dispatchWithProps"],"sources":["C:/Users/Asus/Desktop/LCF-Deployment/node_modules/@mui/base/useListbox/useControllableReducer.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport * as React from 'react';\r\nimport { ActionTypes } from './useListbox.types';\r\nimport areArraysEqual from '../utils/areArraysEqual';\r\n\r\n/**\r\n * Gets the current state. If the selectedValue is controlled,\r\n * the `value` prop is the source of truth instead of the internal state.\r\n */\r\nfunction getControlledState(internalState, props) {\r\n  if (props.value !== undefined) {\r\n    return _extends({}, internalState, {\r\n      selectedValue: props.value\r\n    });\r\n  }\r\n  return internalState;\r\n}\r\nfunction areOptionsEqual(option1, option2, optionComparer) {\r\n  if (option1 === option2) {\r\n    return true;\r\n  }\r\n  if (option1 === null || option2 === null) {\r\n    return false;\r\n  }\r\n  return optionComparer(option1, option2);\r\n}\r\n\r\n/**\r\n * Triggers change event handlers (onChange and onHighlightChange) when reducer returns changed state.\r\n *\r\n * @param nextState The next state returned by the reducer.\r\n * @param internalPreviousState The previous state. If the component is controlled, this is merged with the props to determine the final state.\r\n * @param propsRef The props with defaults applied.\r\n * @param lastActionRef The last action that was dispatched.\r\n */\r\nfunction useStateChangeDetection(nextState, internalPreviousState, propsRef, lastActionRef) {\r\n  React.useEffect(() => {\r\n    var _previousState$select;\r\n    if (!propsRef.current || lastActionRef.current === null) {\r\n      // Detect changes only if an action has been dispatched.\r\n      return;\r\n    }\r\n    if (lastActionRef.current.type === ActionTypes.setValue || lastActionRef.current.type === ActionTypes.setHighlight) {\r\n      // Don't fire change events when the value has been changed externally (e.g. by changing the controlled prop).\r\n      return;\r\n    }\r\n    const previousState = getControlledState(internalPreviousState, propsRef.current);\r\n    const {\r\n      optionComparer,\r\n      onChange\r\n    } = propsRef.current;\r\n    const previousSelectedValues = (_previousState$select = previousState == null ? void 0 : previousState.selectedValues) != null ? _previousState$select : [];\r\n    const nextSelectedValues = nextState.selectedValues;\r\n    if (!areArraysEqual(nextSelectedValues, previousSelectedValues, optionComparer)) {\r\n      onChange == null ? void 0 : onChange(lastActionRef.current.event, nextSelectedValues);\r\n    }\r\n\r\n    // Fires the highlightChange event when reducer returns changed `highlightedValue`.\r\n    if (!areOptionsEqual(internalPreviousState.highlightedValue, nextState.highlightedValue, propsRef.current.optionComparer)) {\r\n      var _propsRef$current, _propsRef$current$onH;\r\n      (_propsRef$current = propsRef.current) == null ? void 0 : (_propsRef$current$onH = _propsRef$current.onHighlightChange) == null ? void 0 : _propsRef$current$onH.call(_propsRef$current, lastActionRef.current.event, nextState.highlightedValue);\r\n    }\r\n    lastActionRef.current = null;\r\n  }, [nextState.selectedValues, nextState.highlightedValue, internalPreviousState, propsRef, lastActionRef]);\r\n}\r\n\r\n/**\r\n * @ignore - do not document.\r\n */\r\nexport default function useControllableReducer(internalReducer, externalReducer, props) {\r\n  var _ref;\r\n  const {\r\n    value,\r\n    defaultValue\r\n  } = props.current;\r\n  const actionRef = React.useRef(null);\r\n  const initialSelectedValues = (_ref = value === undefined ? defaultValue : value) != null ? _ref : [];\r\n  const initialState = {\r\n    highlightedValue: null,\r\n    selectedValues: initialSelectedValues\r\n  };\r\n  const combinedReducer = React.useCallback((state, action) => {\r\n    actionRef.current = action;\r\n    if (externalReducer) {\r\n      return externalReducer(getControlledState(state, action.props), action);\r\n    }\r\n    return internalReducer(getControlledState(state, action.props), action);\r\n  }, [externalReducer, internalReducer]);\r\n  const [nextState, dispatch] = React.useReducer(combinedReducer, initialState);\r\n  const dispatchWithProps = React.useCallback(action => {\r\n    dispatch(_extends({\r\n      props: props.current\r\n    }, action));\r\n  }, [dispatch, props]);\r\n  const previousState = React.useRef(initialState);\r\n  React.useEffect(() => {\r\n    previousState.current = nextState;\r\n  }, [previousState, nextState]);\r\n  useStateChangeDetection(nextState, previousState.current, props, actionRef);\r\n  return [getControlledState(nextState, props.current), dispatchWithProps];\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}